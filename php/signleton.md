# 5. signleton-单例模式

**单例模式被公认为是 [反面模式](https://laravel-china.org/docs/php-design-patterns/2018/anti-pattern)，为了获得更好的可测试性和可维护性，请使用『[依赖注入模式](https://laravel-china.org/docs/php-design-patterns/2018/DependencyInjection)』。**

-- 摘自: laravel

## 1. 并发

 (这对目前的php而言可以略过)由于只有一个对象实例的原因， 在多线程方面的可选择性也会受到限制。 对单例类的访问会被通过synchronisation 等锁的方式受到限制。如果能维持这些对象的多个实例， 那么就可以根据运行的线程的多少来决定对象的实例数量， 从而增加代码的容量。

## 2. 单一原则

 单例模式违背的单一原则： 单例类自己控制了自己的创建和生命周期。 

## 3. 总结

 单例模式最好使用依赖注入替代
 
# 使用

还是根据理解，建议使用依赖注入模式来替代。
但实际工作中，亦或者装逼（比如面试）你必须掌握它，理解他，才能更合理的判断去不去使用它

> **PHP的问题**         PHP语言是一种解释型的脚本语言，这种运行机制使得每个PHP页面被解释执行后，所有的相关资源都会被回收。也就是说，PHP在语言级别上没有办法让某个对象常驻内存，这和asp.net、Java等编译型是不同的，比如在Java中单例会一直存在于整个应用程序的生命周期里，变量是跨页面级的，真正可以做到这个实例在应用程序生命周期中的唯一性。然而在PHP中，所有的变量无论是全局变量还是类的静态成员，都是页面级的，每次页面被执行时，都会重新建立新的对象，都会在页面执行完毕后被清空，这样似乎PHP单例模式就没有什么意义了，所以PHP单例模式我觉得只是针对单次页面级请求时出现多个应用场景并需要共享同一对象资源时是非常有意义的。

> 简单点说： PHP的单例模式其实的存活周期其实也就在一次请求而已，避免的也是在一次请求中多次创建实例

> 当然在使用*swoole* 这些的时候，单例模式我们就要思考的更多了

## 1. 优点 

1. 提供了对唯一实例的受控访问。
2. 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
3. 允许可变数目的实例。

## 2. 缺点

1. 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
2. 单例类的职责过重，在一定程度上违背了“单一职责原则”。
3. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状
   态的丢失。
  

> 关于第二点，单例类是要**一定程度违背了单一职责**，这是设计模式的设计原则之一，为什么说是一定程度呢，主要是**职责过重**、**控制自己的生命周期**

代码简介之道的描述

1. 通常使用一个全局实例，为什么这么糟糕？因为你隐藏了依赖关系在你的项目的代码中，而不是通过接口暴露出来。你应该有意识的去避免那些全局的东西。
2.  他们违背了单一职责原则：他们会自己控制自己的生命周期。
3.  这种模式会自然而然的使代码耦合在一起。这会让他们在测试中，很多情况下都理所当然的不一致。
4.  他们持续在整个项目的生命周期中。另外一个严重的打击是当你需要排序测试的时候，在单元测试中这会是一个不小的麻烦。为什么？因为每个单元测试都应该依赖于另外一个。

* 单一职责： 
1.  避免相同的职责分散到不同的类中
2.  一个类承担太多职责

## 3. 实现原理

1. 一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；
2. 当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；
3. 同时我们 还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。

## Example

[示例代码](https://github.com/viliy/design-patterns.git )

```
final class Instance
{
    /**
     * 用来保存对象的私有属性，防止修改
     * 因为要在实例化之前判断，所以此属性为静态的。
     *
     * @var
     */
    private static $instance;

    /**
     * 方法前面加 final 代表不能重写，类前面加 final 代表不能被继承。
     *
     * Instance constructor.
     */
    final protected function __construct()
    {
    }

    /**
     * 克隆方法私有化，避免外部克隆(创建副本)。
     */
    final private function __clone(){}
    
    /**
     * 防止反序列化（这将创建它的副本）
     */
    private function __wakeup(){}

    /**
     * @return Instance
     */
    public static function getInstance()
    {
        if (is_null(self::$instance)) {
            self::$instance = new Instance();
        }
        return self::$instance;
    }

    public function mmp()
    {
        echo 'God';
    }

    public function fuck()
    {
        echo 'Fuck';
    }
}

```

判断

```

require __DIR__ . '/vendor/autoload.php';

use ZhaQ\DesignPatterns\Instance\Instance;


$objO=Instance::getInstance();
$objT=Instance::getInstance();

/**
 * 什么情况下两个对象会使相等的？在属于一个对象的情况下。否则即使实例化的是一个类，相同的两个属性+方法的对象也不相等。
 */
if($objO===$objT){
    echo "是一个对象";
}else{
    echo "不是一个对象";
}

echo PHP_EOL;
$objO->fuck();

// output
// 是一个对象
// Fuck

```