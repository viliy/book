# 2. 关于引用

```php
$a = [1,2,3,];

echo implode(',', $a), PHP_EOL;

foreach ($a as &$item){}

echo implode(',', $a), PHP_EOL;

//var_dump($a);

foreach ($a as $item){}

//var_dump($a);

echo implode(',', $a), PHP_EOL;
```

先说说我原先的理解：

> 第一个echo: 1,2,3 // 这个毫无疑问 第二个echo? 1,2,3 还是 3,3,3 呢？ ?&gt; 第三个又是什么呢？

```text
1,2,3
1,2,3
3,3,3
```



{% hint style="error" %}
上面是错的
{% endhint %}

> 这才是对的



```text
 1,2,3 
 1,2,3
 1,2,2
```

第三个应该是： 1,2,2
wtf? 老实说，我开始还真没get到  1，2，2。 很明显我SB了

查阅了相关描述：

首次引用遍历

```php
$a = [1,2,3,];

foreach($a as &$item){}

```
> 第一次是引用遍历形式，而在PHP中，foreach里的变量不是只在foreach这个范围内有效，而是在整个下文程序中都是有效的。
所以，第一次遍历，此时$item得到的是$a数组最后的一个引用，也就是 item == $a[2] == 3，当前$v是$a[2]的引用。


第二次
```php
$a = [1,2,3,];
foreach($a as $item) {}

```
> 我们来看这里的执行情况，这里执行3次，我们从第一次到第三次的执行分析。
>> 首先第一次foreach后，$item = $a[0] == 1，也就是$item被赋值为$a[0]，而从上文我们知道$item是$a[2]的引用，所以，此时相当于$a[2] = $item = $a[0] == 1，也就是说，此时$a = [1,2,1]；

>>同理，来看第二次foreach，此时从第一次循环所看到的$a = [1,2,1]可知$item = $a[1] == 2,已知$item是$a[2]的引用，所以此时相当于$a[2] = $item = $a[1] == 2，也就是说，此时$a = [1,2,2];

>> 由此可见，第三次循环，那么$item = $a[2]，而从第二次循环可知$a = [1,2,2]，所以此时$item == 2，已知$item是$a[2]的引用，所以此时相当于$a[2] = $item = $a[2] == 2，也就是说，此时$a = [1,2,2]；


简单来说，执行完引用遍历时， $item 将会成为数组最后一个元素的引用。
当执行第二次遍历时，$item被不断赋值，直到倒数第二次遍历时， $item = $a[count($a) - 2] = $a[count($a) - 1] ;
此时最后两个元素相等了


## 换种思路

```php

$a = [1,2,3,];

for ($i = 0; $i < count($a); $i++) {
    $item = &$a[$i];
}

// $item = &$a[2];

for ($i = 0; $i < count($a); $i++) {
    $item = $a[$i];
}

echo $item;
```

> 这时候输出的是什么呢？
>
> > 对的： _2_；

我发现我好蠢 = =

