# 2. 关于引用

先简单的理解

```php

<?php
$a = 23;
$b = $a;
$b = 42;
var_dump($a); // int(23)
var_dump($b); // int(42)


$a = 23;
$b = &$a;
$b = 42;
var_dump($a); // int(42)
var_dump($b); // int(42)
?>

[参考Summer解释](https://zhuanlan.zhihu.com/p/35107602)
> 现在 $a 的值也改变成了 42 。 事实上，$a 和 $b 之间没有任何区别，它们都使用了同一个变量容器（又名： zval ）。
> 将这两者分开的唯一方法是使用 unset() 函数销毁其中任何一个变量。


```


```php
$a = [1,2,3,];

echo implode(',', $a), PHP_EOL;

foreach ($a as &$item){}

echo implode(',', $a), PHP_EOL;

//var_dump($a);

foreach ($a as $item){}

//var_dump($a);

echo implode(',', $a), PHP_EOL;
```

这样理解对不：

> 第一个echo: 1,2,3 // 这个毫无疑问 
> 第二个echo? 1,2,3 还是 3,3,3 呢？
> 第三个又是什么呢？

```text
1,2,3
1,2,3
3,3,3
```

{% hint style="danger" %}
上面是错的
{% endhint %}

> 这才是对的

```text
 1,2,3 
 1,2,3
 1,2,2
```

第三个应该是： 1,2,2 why?

首次引用遍历

```php
$a = [1,2,3,];

foreach($a as &$item){}
```

> 第一次是引用遍历形式，而在PHP中，foreach里的变量不是只在foreach这个范围内有效，而是在整个下文程序中都是有效的。 所以，第一次遍历，此时$item得到的是$a数组最后的一个引用，也就是 item == $a\[2\] == 3，当前$v是$a\[2\]的引用。

第二次

```php
$a = [1,2,3,];
foreach($a as $item) {}
```

> 我们来看这里的执行情况，这里执行3次，我们从第一次到第三次的执行分析。
>
> > 首先第一次foreach后，*$item = $a\[0\] = 1*，也就是*$item*被赋值为*$a\[0\]*，而从上文我们知道*$item*是*$a\[2\]*的引用，所以，此时相当于*$a\[2\] = $item = $a\[0\] = 1*，也就是说，此时 *$a = \[1,2,1\]*；
> >
> > 同理，来看第二次foreach，此时从第一次循环所看到的 *$a = \[1,2,1\]* 可知 *$item = $a\[1\] = 2*,已知*$item*是 *$a\[2\]* 的引用，所以此时相当于 *$a\[2\] = $item = $a\[1\] = 2* ，也就是说，此时 *$a = \[1,2,2\]*;
> >
> > 由此可见，第三次循环，那么 *$item = $a\[2\]* ，而从第二次循环可知 *$a = \[1,2,2\]* ，所以此时 *$item = 2* ，已知$item是 *$a\[2\]* 的引用，所以此时相当于 *$a\[2\] = $item = $a\[2\] = 2* ，也就是说，此时 *$a = \[1,2,2\]*；

简单来说，执行完引用遍历时， $item 将会成为数组最后一个元素的引用。 当执行第二次遍历时，$item被不断赋值，直到倒数第二次遍历时， *$item = $a\[count\($a\) - 2\] = $a\[count\($a\) - 1\]*  ; 此时最后两个元素相等了

## 换种简单思路

```php
$a = [1,2,3,];

for ($i = 0; $i < count($a); $i++) {
    $item = &$a[$i];
}

// $item = &$a[2];

for ($i = 0; $i < count($a); $i++) {
    $item = $a[$i];
}

echo $item;
```

> 这时候输出的是什么呢？
>
> > 对的： _2_；
